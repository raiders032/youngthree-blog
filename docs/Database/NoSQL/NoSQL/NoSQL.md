---
title: "NoSQL"
description: "NoSQL 데이터베이스의 개념, 종류, 특징과 장단점을 알아봅니다. Key-Value, Document, Column-Family, Graph 등 다양한 NoSQL 데이터베이스의 특성과 적절한 사용 사례를 상세히 설명합니다."
tags: [ "DATABASE", "NOSQL", "SYSTEM_DESIGN", "BACKEND" ]
keywords: [ "NoSQL", "키-값 데이터베이스", "문서형 데이터베이스", "컬럼 기반 데이터베이스", "그래프 데이터베이스", "MongoDB", "Redis", "Cassandra", "Neo4j", "데이터베이스 설계", "분산 데이터베이스" ]
draft: false
hide_title: true
---

## 1 NoSQL

- 우리가 아는 NoSQL이란 용어의 기원은 런던 출신 개발자 조핸 오스카슨이 조직한 비공식적 모임으로 거슬러 올라갑니다.
	- 이 모임은 "오픈소스, 분산, 비관계형 데이터베이스"를 위한 모임이였습니다.
- 조핸은 모임을 위한 이름을 짓는데 트위어 해시 태그로 쓰기 좋고, 짧고 기억하기 쉽지만 검색 결과가 많지 않아 빨르게 검색할 수 있는 이름을 원했습니다.
- 그래서 NoSQL이라는 이름을 지었습니다. NoSQL이란 단어는 퍼져나갔지만 정확한 정의는 없습니다.
- 이 모임에 볼드모트, 카산드라, 다이노마이트, H베이스, 하이버테이블, 카우치DB, 몽고DB가 참석했지만 NoSQL이란 용어는 이들 데이터베이스에 국한되지 않습니다.
- 일반적으로 통용되는 정의도 없고, 정의를 내릴 권위자도 없기 때문에 NoSQL의 공통 특성에 대해서 이야기해보겠습니다.

### 1.1 NoSQL의 공통 특성

- 아래 설명하는 NoSQL 데이터베이스라고 설명하는 것들의 공통 특징입니다.
	- 하지만 이중 어느것도 명확하지 않으며 NoSQL에 대한 일관성 있는 정의는 없습니다.
	- 아래의 공통 특성은 대강의 특징 집합 정도로 이해하면 됩니다.
- NoSQL은 SQL을 사용하지 않습니다.
	- 하지만 일부 NoSQL은 질의어를 지원합니다. 카산드라의 CQL은 SQL과 비슷한 문법을 사용합니다.
	- 하지만 어떤 NoSQL 데이터베이스도 표준 SQL 개념보다 융통성 있는 것을 만들어 내지 않았습니다.
- NoSQL 데이터베이스는 보통 오픈 소스 프로젝트입니다.
- NoSQL 데이터베이스는 대부분 클러스터 환경에서 실행할 목적으로 만들어 졌습니다.
	- 최초 모임에서 논의된 데이터베이스에 대해서는 확실히 이런 목적이 있었습니다.
	- 그러나 모든 NoSQL 데이터베이스가 클러스터 환경에서 실행되는 것은 아닙니다.
- NoSQL은 데이터베이스 스키마 없이 동작하며, 구조에 대한 정의를 변경할 필요 없이 데이터베이스 레코드에 자유롭게 필드를 추가할 수 있습니다.
	- 이런 데이터는 균일하지 않은 데이터나 커스텀 필드를 다룰 때 특히 유용합니다.
	- 관계형 데이터베이스에서는 customField6 같은 이름을 사용하거나 처리하기도, 이해하기도 어려움 커스텀 필드 테이블을 만들어야 합니다.

### 1.2 NoSQL 데이터베이스 종류

- 문서 기반: MongoDB, CouchDB (JSON 또는 BSON 형식의 문서를 사용)
- 키-값 저장소: Redis, DynamoDB (단순한 키-값 쌍을 사용)
- 컬럼 기반: Cassandra, HBase (컬럼 패밀리를 사용하여 빅데이터를 효율적으로 처리)
- 그래프 기반: Neo4j, Amazon Neptune (엔티티 간의 관계를 그래프 형태로 저장)

## 2 관계형 데이터베이스의 가치

- NoSQL에 대해 이야기하기 전에 관계형 데이터베이스가 어떤 가치와 한계를 가지고 있는지 살펴보고 NoSQL이 왜 등장했는지 이해해보겠습니다.
- 업계에서 대부분의 기간 동안 데이터를 저장하는 데는 관게형 데이터베이스를 사용했습니다.
- 엔터프라이즈 애플리케이션 분야에서 아키텍트는 어떤 관계형 데이터베이스를 사용할지만 결정하면 됐습니다.
- 이 오랜 지배 기간이 끝나고 NoSQL 데이터베이스가 등장했습니다.
- 먼저 관계형 데이터 베이스가 어떻게 지배적인 위치를 차지했는지 살펴보겠습니다.

### 2.1 데이터 저장

- 데이터베이스의 가장 중요한 가치는 많은 양의 데이터를 저장하는 데 있습니다.
- 컴퓨터 아키텍처에는 대부분 구 종류의 저장장치 개념이 있습니다.
	- 빠르지만 휘발성인 메모리
	- 느리지만 비휘발성인 디스크
	- 메모리는 휘발성이기 때문에 데이터를 읽지 않으려면 디스크에 저장해야 합니다.
- 워드 프로세서 같은 애플리케이션은 데이터를 운영 체제의 파일 시스템에 저장합니다.
- 그러나 엔터프라이즈 애플리케이션은 데이터베이스에 데이터를 저장합니다.
- 데이터베이스는 많은 양의 데이터를 저장할 때 파일 시스템보다. 뛰어난 융통성을 제공해 데이터를 쉽게 검색하고 수정할 수 있습니다.

### 2.2 동시성

- 엔터프라이즈 애플리케이션은 많은 사람이 동시에 같은 데이터를 보고 수정할 수 있습니다.
- 따라서 호텔 방이 이중으로 예약되는 것 같은 사태를 피하려면 이런 상호작용을 조율하는 것을 고민해야 합니다.
- 관계형 데이터베이스는 트랜잭션을 통해 이런 문제를 해결하는데 도움을 줍니다.
	- 트랜잭션 메커니즘이 동시성과 관련된 복잡성을 억제하는데 도움이 됩니다.
- 트랜잭션은 오류 처리 역할도 합니다.
	- 트랜잭션을 사용하면서 오류가가 발생한 경우 롤백을 통해 데이터베이스를 이전 상태로 되돌릴 수 있습니다.

### 2.3 통합

- 엔터프라이즈 애플리케이션은 서로 다른 팀이 작성한 여러 애플리케이션이 협업하여 자곧ㅇ합니다.
- 애플리케이션은 똑같은 데이터를 사용해야 할 때가 있고, 한 애플리케이션에서 수정한 데이터가 다른 애플리케이션에서도 사용되어야 할 때가 있습니다.
- 이렇게 하는 가장 흔한 방법은 통합 데이터베이스 공유 방식을 사용하는 것입니다.
- 한 데이터베이스를 사용하면 모든 애플리케이션이 다른 애플리케이션의 데이터에 쉽게 접근할 수 있습니다.
- 데이터베이스 동시성 제어 기능을 통해 한 애플리케이션에서 여러 사용자를 처리하는 것과 똑같은 방법으로 여러 애플리케이션을 처리합니다.

## 3 관계형 데이터베이스의 한계

### 3.1 객체-관계 불일치

- 애플리케이션 개발자에게 가장 큰 불만은 객체-관계 불일치 문제입니다.
- 객체-관계 불일치란 관계형 모델과 메모리 내 데이터 구조 간의 불일치를 의미합니다.
- 관계형 데이터 모델에서는 테이블과 행 즉 관계와 튜플로 데이터를 구조화 합니다.
- 튜플은 이름-값 쌍의 집합이고 관계는 튜플의 집합입니다.
- 관계형 튜플 안의 값은 단순해야 하며, 중첩된 레코드라 리스트 등 다른 구조를 가질 수 없다는 제약이 있습니다.
- 메모리 내 데이터 구조에서는 이러한 제약이 없어 관계보다 훨씬 복잡한 구조를 사용할 수 있습니다.
- 잘 알려진 매핑 패턴을 구현한 하이버네이트 같은 객체-관계 매핑 프레임워크가 널리 불일치가 완화되었지만 매핑 문제는 여전히 논쟁거리입니다.

### 3.2 애플리케이션 데이터베이스와 통합 데이터베이스

- 통합 데이터베이스란 여러 애플리케이션이 공유하는 데이터베이스를 의미합니다.
- 통합 데이터베이스를 공유하는 방식에는 장점도 있지만 단점도 있습니다.
- 여러 애플리케이션을 통합하려고 설계한 구조는 단일 애플리케이션 구조보다 복잡합니다.
- 애플리케이션 마다 구조와 성능 요건이 다릅니다.
	- 어떤 애플리케이션에서는 인덱스가 필요하지만 이 인덱스 때문에 다른 애플리케이션은 데이터 입력 성능에 영향을 받을 수 있습니다.
- 각 애플리케이션을 다른 팀이 만들기 떄문에 모든 애플리케이션이 정합성을 보장하는 방식으로 데이터를 갱신하는지 확인하기 어렵습니다.
- 이러한 경우 애플리케이션 데이터베이스를 사용하는 것이 좋습니다.
- 애플리케이션 데이터베이스란 특정 애플리케이션만을 위한 데이터베이스를 의미합니다. 즉 공유하지 않고 독립적으로 사용하는 데이터베이스입니다.
	- 해당 애플리케이션을 사용하는 팀만 데이터베이스 구조를 알면 되고, 스키마를 유지하고 개선하는 일이 쉬워집니다.
	- 데이터베이스와 애플리케이션 코드를 모두 통제할 수 있어, 정합성에 대한 코드를 애플리케이션에 직접 구현할 수 있습니다.

### 3.3 클러스터의 공격

- 데이터와 트래픽이 증가하면서 더 많은 컴퓨팅 자원이 필요해졌습니다.
- 이런 증가를 처리하는 두 가지 방식으로 수직 확장과 수평 확장이 있습니다.
- 수직 확장
	- 단일 장비의 성능을 향상시키는 것입니다.
	- 장비의 성능을 향상시키는 방법으로는 CPU, 메모리, 디스크를 업그레이드하는 방법이 있습니다.
	- 이 방법은 장비의 물리적 한계에 도달하면 더 이상 확장할 수 없습니다.
	- 또한 장비의 가격이 엄청 비싸집니다.
- 수평 확장
	- 여러 장비로 확장하는 것입니다.
	- 여러 장비로 확장하는 것이기 때문에 비교적 저렴하게 확장할 수 있습니다.
	- 또한 여러 장비로 확장하면 장애가 발생했을 때 다른 장비로 서비스를 계속 제공할 수 있습니다. (가용성 향상)
- 관계형 데이터베이스는 클러스터에서 동작하도록 설계되지 않았습니다.
- 오라클 RAC나 마이크로소프트 SQL 서버 같은 데이터베이스는 공유 디스크 개념을 사용합니다.
	- 공유 디스크는 여러 장비에서 동시에 접근할 수 있는 디스크를 의미합니다.
	- 클러스터를 인식할 수 있는 파일 시스템을 사용해 고가용성 디스크 서브시스템에 데이터를 기록합니다.
	- 이런 경우 디스크 서브 시스템이 SPOF(Single Point of Failure)가 될 수 있습니다.
- 관계형 데이터베이스에서도 데이터 집합을 분리하고 각 데이터 집합을 별도 서버에서 처리하도록 하는 샤딩이라는 기술을 사용할 수 있습니다.
	- 이렇게 하면 부하를 분산할 수 있습니다.
	- 하지만 애플리케이션에서 모든 샤딩을 제어해야 하는 번거로움이 있습니다.
	- 즉 어떤 데이터를 어느 데이터베이스 서버에서 처리해야 하는지 애플리케이션에서 결정해야 합니다.
	- 또 여러 샤드에 걸치는 쿼리나 참조 정합성, 트랜잭션, 일관성 제어 같은 것은 물 건너갑니다.
	- 여기에 대해서는 흔히 하는 말이 '부자연스럽다'는 것입니다.
	- 여기에 라이선스 비용 문제로 상황은 더 악화됩니다.

## 4 왜 NoSQL인가?

### 4.1 애플리케이션 개발 생상성

- 많은 애플리케이션 개발 노력이 메모리 내 데이터 구조를 관계형 데이터베이스에 매핑하는데 소모된다.
- NoSQL 데이터베이스는 애플리케이션의 필요에 좀 더 적합한 데이터 모델을 제공해 애플리케이션과 데이터베이스의 상호작용을 단순화한다.

### 4.2 대규모 데이터

- 많은 조직이 더 많은 데이터를 수집해 빨리 처리하는 것이 중요하다.
- 관계형 데이터베이스로 이런 작업읋 하는 것이 가능하다 할지라도 비용이 매우 많이 듭니다.
	- 관계형 데이터베이스는 한 대의 장비에서 실행되도록 설계되었기 때문입니다.
	- 작고 값싼 장비 여러대로 구성된 클러스터에서 대량의 데이터를 처리하는 것이 더 경제적입니다.
- 많은 NoSQL 데이터베이스는 클러스터에서 실행되도록 설계되어 빅 데이터 시나리오에도 적합합니다.

## 5. 집합적 데이터 모델

- 데이터 모델이란 데이터를 인식하고 조작하는데 사용되는 모델을 말합니다.
- NoSQL 솔루션은 각각 다른 모델을 사용하며 아래와 같이 구분합니다.
	- 키-값
	- 문서
	- 컬럼 패밀리
	- 그래프
- 처음 셋은 집합 지향이라 불리는 특징을 공유합니다.

### 5.1 집합

- 관계형 모델에서는 저장하고자 하는 정보를 튜플(행)으로 나눕니다.
	- 튜플은 제한적인 데이터 구조입니다.
	- 여러개의 단순한 값을 모아놓은 것입니다.
	- 한 튜플을 다른 튜플에 넣어 중첩 레코드를 만들 수 없습니다.
- **집합 지향**은 다른 접근법을 취합니다.
	- 튜플의 집합보다 더 복잡한 구조를 데이터의 단위로 다룹니다.
	- 리스트나 중첩 레코드를 허용하는 복잡한 레코드로 생각하면 됩니다.
	- 이러한 복잡한 레코드에 대한 공통 용어가 없으므로 집합이라 부르겠습니다.
- 집합은 도메인 주도 개발에서 나온 용어입니다.
	- 집합은 단위로 다루고 싶은 관련된 객체의 무리를 뜻합니다.
	- 집합은 데이터 조작과 일관성 관리가 됩니다.
	- 원자적으로 집합을 업데이트하기 때문입니다.
	- 집합은 복제나 샤딩에서도 자연스러운 단위이기 때문에 클러스터에서 데이터를 처리하는 것도 쉽습니다.

### 5.2 집합의 경계

- 집합의 경계를 어떻게 그리는 것이 옳을지에 대한 일반적인 해답은 없습니다.
- 집합의 경계는 데이터를 조작하는 방식에 따라 완전히 달라집니다.
- 고객 데이터를 접근할 때 그 고객의 모든 주문 정보도 한꺼번에 접근하는 경우가 많다면 단일 집합이 좋을 것입니다.
- 그러나 한 번에 한 주문에 집중하는 경우가 대부분이라면 각각을 별도의 집합으로 분리하는 것이 좋습니다.

### 5.3 집합 무지

- 관계형 데이터베이스는 데이터 모델에 집합 개념이 없어 집합 무지라고 부릅니다.
- NoSQL 세계에서 그래프 데이터베이스도 집합 무지입니다.
- 집합 무지는 나쁜 것이 아닙니다.
- 집합의 경계를 제대로 그리는 것은 어려운 일이기 때문입니다.
	- 똑같은 데이터가 여러 가지 다른 맥락에서 사용되는 경우 특히 그렇습니다.
- 예를 들어 고객 주문을 할 때나 주문을 검토할 때, 판매자가 주문을 처리할 때 주문은 좋은 집합이지만 판매자가 몇 달간의 제품 판매 상황을 분석할 때 주문 집합은 문제가 됩니다.
	- 제품 판매 분석과 같이 다른 맥락에서 필요한 정보를 추출하려면, 이 주문 집합 전체를 탐색하며 필요한 정보를 추출해야 합니다.
	- 예를 들어, 특정 제품의 판매량을 알기 위해서는 모든 주문을 검사하여 해당 제품이 포함된 주문을 찾아야 합니다.

### 5.4 집합 지향의 장점

- 집합 지향이 중요한 이유는 클러스터 환경에서 데이터를 효율적으로 처리할 수 있기 때문입니다.
- 이를 이해하기 위해 다음 예시를 살펴보겠습니다:
	- 주문 시스템에서 "주문-상품-배송" 정보가 서로 다른 노드에 분산되어 있다고 가정해봅시다.
	- 하나의 주문 정보를 조회할 때마다 여러 노드에 접근해야 하므로 성능이 저하됩니다.
	- 더구나 네트워크 지연이나 일부 노드의 장애가 발생하면 전체 조회가 실패할 수 있습니다.
- 집합 지향 데이터베이스는 이 문제를 다음과 같이 해결합니다:
	- 함께 조회되는 데이터를 하나의 "집합"으로 묶어서 같은 노드에 저장합니다.
	- 예를 들어, 주문과 관련된 모든 정보(상품 목록, 배송 정보, 결제 정보 등)를 하나의 문서나 레코드로 저장합니다.
	- 이렇게 하면 주문 조회 시 단 하나의 노드에만 접근하면 되므로 성능이 향상됩니다.
- 이러한 특성 때문에 NoSQL이 대규모 분산 시스템에서 각광받고 있습니다
	- 단일 노드 접근으로 필요한 모든 데이터를 얻을 수 있어 응답 시간이 빨라집니다.
	- 일부 노드의 장애가 다른 데이터 접근에 영향을 미치지 않아 안정성이 향상됩니다.

### 5.5 트랜잭션

- NoSQL은 ACID 트랜잭션을 지원하지 않아 데이터 일관성을 희생하는 것이라고 흔히 말합니다.
- 보통의 집합 지향 데이터베이스는 여러 집합을 포괄하는 ACID 트랜잭션을 지원하지 않습니다.
	- 대신 한 번에 한 집합에 대한 원자적 조작은 지원합니다.
	- 여러 집합을 원자적으로 조작해야 한다면 애플리케이션 코드에서 직접 관리해야 합니다.
- 그래프 데이터베이스나 다른 집합 무지 데이터베이스는 ACID 트랜잭션을 지원하는 경우가 많습니다.

### 5.6 키-값 모델

- 키-값 데이터베이스는 집합 지향적인 데이터 모델을 사용하지만, 집합의 구조는 불투명한 특징이 있습니다.
- 이러한 불투명성의 장점은 다음과 같습니다:
	- 집합 안에 어떤 데이터든 자유롭게 저장할 수 있습니다.
	- 크기 제한 외에는 데이터 형식에 제약이 없습니다.
- 대부분의 키-값 데이터베이스는 저장된 데이터를 단순한 바이너리처럼 취급합니다.
	- 이는 문서 데이터베이스가 구조화된 형태로 데이터를 저장하는 것과는 대조적입니다.
- 최근에는 키-값 저장소와 문서 데이터베이스의 경계가 모호해지고 있습니다:
	- 많은 문서 데이터베이스들이 키-값 검색을 위해 ID 필드를 추가하고 있습니다.
	- 레디스와 같은 키-값 데이터베이스도 리스트나 세트 같은 구조화된 데이터 타입을 지원하기 시작했습니다.

### 5.7 문서 데이터 모델

- 문서 데이터베이스는 구조화된 집합 지향 데이터 모델을 채택하고 있습니다.
- 주요 특징은 다음과 같습니다:
	- 집합에 허용되는 구조와 타입을 명확하게 정의합니다.
	- 정의된 구조를 통해 데이터 접근에 더 많은 유연성을 제공합니다.
	- 키뿐만 아니라 문서 내의 어떤 필드로도 데이터에 접근할 수 있습니다.
	- 전체 문서가 아닌 특정 필드만 조회하거나, 문서 내용을 기반으로 인덱스를 생성할 수 있습니다.
- 최근에는 키-값 저장소와 문서 데이터베이스의 경계가 모호해지고 있습니다:
	- 많은 문서 데이터베이스들이 키-값 검색을 위해 ID 필드를 추가하고 있습니다.
	- 레디스와 같은 키-값 데이터베이스도 리스트나 세트 같은 구조화된 데이터 타입을 지원하기 시작했습니다.

## 6. 관계

- NoSQL의 집합 모델은 함께 자주 접근되는 데이터를 하나로 묶어주어 편리합니다.
- 하지만 데이터 간의 관계를 어떻게 모델링할지는 신중히 고민해야 합니다.

### 6.1 집합 모델링의 딜레마

- 예를 들어 고객과 주문 데이터의 관계를 생각해보겠습니다:
- 고객 프로필을 볼 때 주문 내역도 함께 보여주고 싶다면, 고객 정보와 주문을 하나의 집합으로 묶는 게 좋습니다.
- 하지만 주문 처리 시스템에서는 개별 주문을 독립적으로 다루고 싶을 수 있습니다.
- 이처럼 같은 데이터라도 사용 맥락에 따라 다른 구조가 필요할 수 있습니다.

### 6.2 관계 처리 방식

- NoSQL에서 가장 일반적인 방법은 참조를 사용하는 것입니다:
- 주문 데이터에 고객 ID를 포함시켜 참조합니다.
- 필요할 때 이 ID를 사용해 고객 정보를 조회합니다.
- 하지만 이 방식에는 몇 가지 제약이 있습니다:
	- 데이터베이스가 이러한 관계를 이해하지 못하고, 단순히 값으로만 취급합니다.
	- 관계 처리는 전적으로 애플리케이션 코드에서 해야 합니다.

### 6.3 데이터 일관성 문제

- 집합 지향 데이터베이스의 가장 큰 한계는 트랜잭션 범위입니다:
	- 단일 집합 내에서만 원자성이 보장됩니다.
	- 여러 집합을 동시에 수정할 때는 중간에 실패하면 직접 복구 로직을 구현해야 합니다.
	- 하지만 최근 NoSQL도 이러한 한계를 극복하려 노력하고 있습니다:
	- MongoDB는 4.0 버전(2018년)부터 다중 문서 트랜잭션을 지원합니다
- 반면 관계형 데이터베이스는 ACID 트랜잭션으로 여러 테이블의 일관성을 보장합니다.

#### 예시

- NoSQL의 트랜잭션 제약은 두 가지 상황에서 문제가 됩니다
- 여러 집합 간의 업데이트(예: 고객이 주문을 취소할 때)
	- 고객 집합의 주문 내역 수정
	- 주문 집합의 상태 변경
	- 재고 집합의 수량 증가
	- 이 세 가지 작업 중 하나라도 실패하면 데이터 불일치가 발생합니다.
	- NoSQL은 이 세 집합을 하나의 트랜잭션으로 처리할 수 없습니다.
- 동일 타입의 여러 집합 업데이트(예: 가격 정책 변경으로 여러 주문의 금액을 한 번에 수정할 때)
	- 100개의 주문 집합을 동시에 수정해야 하는 경우
	- 50개만 성공하고 실패하면 일부 주문만 새로운 가격이 적용됩니다.
- NoSQL은 여러 주문 집합을 하나의 원자적 작업으로 처리할 수 없습니다.
- 반면 관계형 데이터베이스는 ACID 트랜잭션으로 두 경우 모두 안전하게 처리 가능합니다.

### 6.4 선택 기준

- 데이터 간에 복잡한 관계가 많다면 관계형 데이터베이스가 더 적합할 수 있습니다:
- 데이터 간의 관계가 명확하고 일관성이 중요하다면 RDBMS를 선택하세요.
- 독립적인 데이터가 많고 확장성이 중요하다면 NoSQL이 좋은 선택일 수 있습니다.

---
title: "NoSQL"
description: "NoSQL 데이터베이스의 개념, 종류, 특징과 장단점을 알아봅니다. Key-Value, Document, Column-Family, Graph 등 다양한 NoSQL 데이터베이스의 특성과
적절한 사용 사례를 상세히 설명합니다."
tags: [ "DATABASE", "NOSQL", "SYSTEM_DESIGN", "BACKEND" ]
keywords: [ "NoSQL", "키-값 데이터베이스", "문서형 데이터베이스", "컬럼 기반 데이터베이스", "그래프 데이터베이스", "MongoDB", "Redis", "Cassandra", "Neo4j", "데이터베이스 설계", "분산 데이터베이스" ]
draft: false
hide_title: true
---

## 7. 스키마 없는 데이터베이스

- NoSQL 데이터베이스의 가장 큰 특징 중 하나는 스키마가 없다는 점입니다.
	- 관계형 데이터베이스는 데이터를 저장하기 전에 반드시 테이블, 컬럼, 데이터 타입 등의 스키마를 먼저 정의해야 합니다.
	- 반면 NoSQL은 이러한 제약에서 자유롭습니다.
- 키-값 데이터베이스와 문서 데이터베이스의 유연성
	- 키-값 데이터베이스는 값에 어떤 데이터든 저장할 수 있습니다.
	- 문서 데이터베이스는 문서 구조에 제약이 없어 유연한 데이터 저장이 가능합니다.
	- 개발 과정에서 데이터 구조를 쉽게 변경할 수 있습니다.
	- 더 이상 필요하지 않은 필드는 간단히 제거할 수 있습니다.
- NoSQL은 균일하지 않은 데이터 처리에 강점이 있습니다.
	- 관계형 데이터베이스는 대부분의 값이 null인 희박 테이블을 생성해야 합니다.
	- 또는 커스텀 필드를 위한 별도의 테이블을 관리해야 합니다.
	- 스키마 변경 시 모든 기존 데이터에 대한 마이그레이션이 필요합니다.
- '암묵적 스키마'란 데이터베이스가 아닌 애플리케이션 코드에 내재된 데이터 구조와 규칙을 의미합니다.
- 하지만 NoSQL의 '암묵적 스키마'는 여러 문제를 일으킬 수 있습니다.
	- 데이터 구조 파악이 어렵습니다.
		- 실제 데이터 구조를 확인하기 위해 애플리케이션 코드를 직접 분석해야 합니다.
		- 문서화가 완벽하지 않으면 데이터 구조 파악이 매우 어려워집니다.
	- 데이터 정합성 관리에 부담이 있습니다.
		- 스키마 검증 책임이 데이터베이스에서 애플리케이션으로 옮겨갑니다.
		- 여러 애플리케이션에서 동일한 검증 로직을 중복 구현해야 할 수 있습니다.
	- 협업 시 문제가 발생할 수 있습니다.
		- 여러 팀이 동일한 데이터베이스를 사용할 때 데이터 구조에 대한 합의와 동기화가 어렵습니다.
		- 한 팀의 데이터 구조 변경이 다른 팀의 애플리케이션에 영향을 미칠 수 있습니다.
- 이러한 문제의 일반적인 해결 방식은 다음과 같습니다.
	- 데이터 접근을 단일 애플리케이션으로 제한하고, 다른 애플리케이션은 API를 통해 접근하도록 설계합니다.
	- 명확한 데이터 구조 문서화와 버전 관리 시스템을 도입합니다.
	- 공통된 데이터 검증 라이브러리를 개발하고 공유합니다.

## 8 분산 모델

- NoSQL이 관심을 끄는 주된 이유는 대규모 클러스터에서 데이터베이스를 실행할 수 있는 능력입니다.
- 수직 확장은 어렵고 비용도 늘아나느데 비해 수평 확장은 비교적 쉽고 저렴합니다.
- 집합은 분산의 자연스러운 단위로 사용되어 집합 지향은 수평 확장과 잘 어울립니다.
- 데이터 분산에는 크게 두 가지 방식이 있습니다. 복제와 샤딩입니다.
- 복제는 같은 데이터를 복사해 여러 노드에 분산하는 방법입니다.
- 샤딩은 각 노드마다 다른 데이터를 저장하는 방법입니다.
- 복제와 샤딩은 서로 직교하는 기법입니다.
	- 둘 중 하나만 사용할 수도 있고 둘 다 사용할 수도 있습니다.
- 복제에는 마스터-슬레이브와 피어 투 피어 두 가지 방식이 있습니다.

### 8.1 단일 서버

- 단일 서버는 데이터베이스를 실행하는 가장 간단한 방법입니다.
- 이 방식을 선호하는 이유는 다른 방식에서 발생하는 모든 복잡성이 사리지기 때문입니다.
- 운영자가 관리하기도 쉽고 애플리케이션 개발자가 생각하기도 쉽습니다.
- 많은 NoSQL이 클러스터 환경을 고려해 만들어졌지만 단일 서버에서 사용한다고 문제가 될 것은 없습니다.
- 그래프 데이터베이스는 단일 서버 환경에서 가장 잘 동작합니다.

### 8.2 샤딩

- 샤딩은 데이터를 여러 노드에 분산하는 방법입니다.
- 데이터의 다른 부분을 다른 서버에 두어 수평 확장을 지원하는 방법입니다.
- 여기에는 두 가지 문제점이 있습니다.
- 데이터를 어떻게 뭉쳐놓으면 한 사용자가 한 서버로부터 데이터를 대부분 얻게 할 수 있느냐 하는 문제입니다.
	- 집합 지향은 바로 이 부분에서 잘 맞습니다. 함께 접근되는 빈도가 높은 데이터를 모으는 것이므로 집합은 분산의 좋은 단위가 됩니다.
- 다른 요소는 부하를 균등하게 분배하는 것입니다.
- 즉 집합을 잘 배치해 모든 노드에 균등하게 분산하고 같은 양의 부하가 걸리도록 해야합니다.
- 과거 많은 경우 샤딩을 애플리케이션 로ㅗ직 일부로 처리했습니다.
- 쿼리를 여러 샤드로 분배하는 작업을 애플리케이션에서 직접 해 주어야 했습니다.
- 샤딩의 균형을 다시 맞출 경우 애플리케이션 코드 수정이 필요합니다.
- NoSQL은 많은 경우 자동 샤딩을 제공합니다.
- 이는 데이터베이스가 샤딩을 자동으로 처리해주는 것을 의미합니다.
- 샤딩은 쓰기와 읽기 성능 모두 향상시킬 수 있습니다.
- 복제는 읽기 성능을 향상시키는 데 도움이 되지만 쓰기 성능은 향상시키지 못합니다.
- 샤딩은 쓰기에 대한 수평 확장 방법을 제공합니다.

### 8.3 복제

- 복제는 데이터를 여러 노드에 복사하는 방법입니다.
- 노드 하나가 프라이머리가 되고 프라이머리는 데이터의 믿을 만한 출처가 됩니다.
- 세컨더리는 프라이머리의 변경 사항이 전파되어 데이터를 복사합니다.
- 모든 업데이트는 프라이머리에만 발생하고 세컨더리는 읽기 전용입니다.
- 읽기는 프라이머리와 세컨더리 모두에서 가능합니다.
- 복제를 통해 읽기 성능에 수평 확장을 제공합니다.
- 그러나 쓰기에 대해서는 여전히 프라이머리의 성능에 의존합니다.
- 복제의 장점은 읽기 복원력입니다.
	- 마스터가 실패해도 세컨더리가 읽기 요청을 처리할 수 있습니다.
	- 마스터 실패 후 세컨더리를 마스터로 승격시켜 마스터 실패를 빠르게 복구할 수 있습니다.
	- 읽기 복원력을 얻으려먼 읽기와 쓰기 경로를 분리해야 합니다.
- 복제의 한계는 비일관성입니다.
	- 프라이머리에 쓰기가 발생하면 세컨더리에 복사되기 전까지 데이터가 일관성이 없습니다.

