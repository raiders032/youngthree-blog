## 1 가변성을 제한하라

- 코틀린은 모듈로 프로그램을 설계합니다.
- 모듈은 클래스, 객체, 함수, 타입 별칭, 톱레벨 프로퍼티 등 다양한 요소로 구성됩니다.
- 이러한 요소 중 일부는 상태를 가질 수 있습니다.
- 예를 들어, 읽고 쓸 수 있는 프로퍼티 var를 사용하거나 mutable 객체를 사용하면 상태를 가질 수 있습니다.

## 2. 상태 관리의 어려움

- 시간의 변화에 따라서 변하는 요소를 표현하는 것은 유용하지만 상태를 적절하게 관리하는 것은 어렵습니다.
- 프로그램을 이해하고 디버그하기 힘들어집니다.
- 가변성이 있으면 코드의 실행을 추론하기 어렵습니다.
  - 시점에 따라 값이 달라질 수 있으므로 현재 어떤 값을 가지고 있는지 알아야 실행을 예측할 수 있습니다.
- 멀티 스레드 프로그램에서 적절한 동기화가 필요합니다.
  - 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있습니다.
- 테스트하기 어렵습니다.
  - 모든 상태를 테스트해야 하므로 테스트 케이스가 많아집니다.
  - 변경이 많으면 많을수록 더 많은 조합을 테스트해야 합니다.
- 상태 변경이 일어날 때 이러한 변경을 다른 부분에 알려야 하는 경우가 있습니다.
  - 예를 들어 정렬되어 있는 리스트에 가변 요소를 추가하면 요소 변경 시 리스트 전체를 다시 정렬해야 합니다.

## 3. 코틀린에서 가변성 제한하기

- 코틀린은 가변성을 제한하기 위해 다양한 방법을 제공합니다.
- 가변성을 제한하기 위한 방법은 아래와 같습니다.
  - 읽기 전용 프로퍼티 사용
  - 가변 컬렉션과 읽기 전용 컬렉션 구분하기
  - 데이터 클래스의 copy

### 3.1 읽기 전용 프로퍼티 사용

- 읽기 전용 프로퍼티는 val로 선언된 프로퍼티입니다.
- 이렇게 선언된 프로퍼티는 마치 값처럼 동작하며 일반적인 방법으로는 값이 변하지 않습니다.
  - 읽기 전용 프로퍼티가 완전 변경 불가능한 것은 아닙니다.
  - 읽기 전용 프로퍼티가 mutable 객체를 참조하는 경우에는 객체의 상태가 변경될 수 있습니다.

**예시**

```kotlin
val list = mutableListOf(1, 2, 3)
list.add(4)
println(list) // [1, 2, 3, 4]
```

- 위의 예시에서 list는 읽기 전용 프로퍼티로 선언되었지만 mutableListOf를 사용하여 가변 리스트를 생성했습니다.
- 이 경우 list는 읽기 전용 프로퍼티이지만 내부의 리스트는 가변입니다.
- 따라서 list의 상태는 변경될 수 있습니다.