## 1 SOLID

- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리함
- 소프트웨어 설계를 이해하기 쉽고 유연하고 유지보수하기 쉽게 만들기 위해 사용되는 원칙 5가지를 뜻한다.
- 5가지 원칙
	- Single Responsibility Principle(단일 책임 원칙)
	- Open-Closed Principle(개방-폐쇄 원칙)
	- Liskov Substitution Principle(리스코프 치환 원칙)
	- Interface Segregation Principle(인터페이스 분리 원칙)
	- Dependency Inversion Principle(의존 역전 원칙)

### 1.1 SOLID를 언제 적용할까?

- SOLID는 디커플링을 중요하게 여기니 대규모 프로젝트일수록 유용하다 따라서 모든 프로젝트에 적용할 수 있다고 생각하지 말자
- 많은 프로젝트의 시작은 직접적/구체적인 설계로 시작하고 규모가 커지면서 유연성이 필요해지면 SOLID를 고려해봐도 좋습니다.

### 1.2 응집도와 결합도

- SOLID는 원칙을 섦명하기에 앞서 응집도와 결합도를 이해하는 것이 중요합니다.
- 응집도(Cohesion)
	- 모듈 내부의 요소들이 얼마나 밀접하게 연관되어 있는지를 나타내는 척도입니다.
  - 응집도는 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있습니다.
	- 하나의 변경을 수용하기 위해 모듈 전체가 변경되면 응집도가 높고 모듈의 일부만 변경되면 응집도가 낮은 것입니다.
	- 하나의 변경을 수용하기 위해 하나의 모듈만 변경된다면 응집도가 높고 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것입니다.
- 결합도(Coupling)
	- 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도입니다.
  - 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있습니다.
  - 내부 구현을 변경했을 때 이것이 다른 모듈에 영향을 미치는 경우 두 모듈 사이의 결합도가 높다고 표현합니다.
  - 반면 퍼블릭 인터페이스를 수정했을 때만 다른 모듈에 영향을 미치는 경우 두 모듈 사이의 결합도가 낮다고 표현합니다.
- SOLID 원칙은 응집도를 높이고 결합도를 낮추는 것을 목표로 합니다.
- 응집도가 높고 결합도가 낮은 모듈은 변경이 발생할 때 파급 효과가 적고, 이해하기 쉽고, 유지보수가 용이합니다.

## 2 Single Responsibility Principle

- 단일 책임 원칙(SRP)은 클래스가 하나의 책임만 가져야 한다는 원칙입니다.
  - 여기서 책임이라는 의미가 잘 이해되지 않을 수 있습니다.
  - SRP에서 책임은 변경으로 해석하는 것이 좋습니다.
  - 즉 단일 책임 원칙은 클래스가 변경되는 이유가 하나만 있어야 한다는 것입니다.
- 한 클래스를 변경하기 위한 한 가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한 가지 이상의 책임을 맡고 있는 것입니다.
- 코드를 보는 대부분의 사람들이 이해할 수 있는 크기로 클래스를 만드는 것이 좋습니다.
- 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것입니다.
- 단일 책임 원칙은 다른 원칙과 비교하여 가장 이해하기도, 적용하기도 어려운 원칙입니다.
  - 아래 단일 책임 원칙 가이드를 참고하여 적용해보세요.

### 2.1 SRP와 응집도

- 응집도 또한 변경의 정도로 측정하기 때문에 SRP와 관련이 깊습니다.
  - SRP는 모듈의 응집도를 높이는 데 도움을 줍니다.
- 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타냅니다.
  - 응집도는 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있습니다.
  - 하나의 변경을 수용하기 위해 모듈 전체가 변경되면 응집도가 높고 모듈의 일부만 변경되면 응집도가 낮은 것입니다.
  - 하나의 변경을 수용하기 위해 하나의 모듈만 변경된다면 응집도가 높고 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것입니다.

### 2.2 SRP 적용하기

- 클래스가 하나 이상의 이유로 변경된다면 응집도가 낮은 것입니다.
  - 이 경우 SRP를 적용해 변경의 이유를 기준으로 클래스를 분리해야 합니다.
- 특정한 메서드 그룹이 특정한 속성 그룹만 사용한다면 응집도가 낮은 것입니다.
  - 함께 사용되는 메서드와 속성 그룹을 기준으로 클래스를 분리해야 합니다.
- 클래스 인스턴스 초기화 시 경우에 따라서 서로 다른 속성들을 초기화한다면 응집도가 낮은 것입니다.
	- 초기화되는 속성의 그룹을 기준으로 클래스를 분리해야 합니다.

### 2.3 단일 책임 원칙 가이드

- 책임을 한 문장으로 적어본다.
  - 클래스의 책임을 설명하는데 `그리고`나 `또는`이 들어간다면 여러 개의 책임을 담당하는 클래스입니다.
- 메서드들을 분류한다.
  - 이름이나 목적이 비슷한 메서드들을 그룹으로 묶어 나열합니다. 
  - 이 메서드 그룹별로 클래스를 분리할 수 있는지 검토합니다.
- 인스턴스 변수와 메서드 사이의 관계를 살펴본다.
  - 일부 인스턴스 변수가 일부 메서드에 의해서만 사용되는지 확인합니다. 
  - 만약 그렇다면 이 인스턴스 변수와 메서드들을 그룹으로 묶어 클래스를 분리할 수 있습니다.
- 서로 배타적으로 초기화되는 인스턴스 변수가 있는지 살펴본다.
  - 어떤 변수들이 초기화될 때 함께 초기화되지 않는 인스턴스 변수들이 있는지 확인합니다.
- 테스트하고 싶은 private 메서드가 있는지 살펴본다.
  - 너무 많은 private 메서드가 있을 때 테스트하고 싶은 private 메서드가 존재하는지 확인합니다.
  - 이런 메서드들은 테스트하기 위해 public으로 변경하는 것보다 클래스를 분리하는 것이 좋습니다.
- 외부 의존성을 찾는다.
  - 데이터베이스 연결이나 외부 시스템과의 연동 등과 같이 외부에 위치하는 불안정한 의존성을 찾습니다.
  - 이런 의존성은 별도의 클래스로 분리하는 것이 좋습니다.

## 3 Open-Closed Principle

- 소프트웨어 개체는 **확장에 대해 열려** 있어야 하고, **수정에 대해서는 닫혀** 있어야 한다.
- 애플리케이션의 요구사항이 변결될 때, 이 변경에 맞게 새로운 행위를 추가해 모듈을 확장 할 수 있다.
- 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.

**어떻게 이것이 가능할까?**

- 정답은 추상화!
	- 모듈이 추상화에 의존하면 수정에 대해 닫혀 있을 수 있다.
	- 그 모듈의 행위는 추상화의 새 파생 클래스를 만듦으로써 확장이 가능하다

**단점**

- OCP를 따르자면 비용이 든다. 적절한 추상화를 만들기 위해서는 개발 시간과 노력뿐만 아니라 이런 추상화는 소프트웨어 설계의 복잡성을 높이기도 한다.
- 개발자가 감당할 수 있는 추상화의 정도에는 한계가 있기 때문이다.
- 지나치고 불필요한 추상화로 설계에 부하를 주지 않으려면 추상화가 실제로 필요할 때까지 기다렸다가 사용하는 편이 좋다.

**OCP를 지키지 못하는 예**

```java
public class MemberService {
  private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

```java
public class MemberService {
  private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

- `MemberRepository` 인터페이스를 구현한 `MemoryMemberRepository` 와 `JdbcMemberRepository` 클래스
- 역할과 구현을 분리해 손쉽게 구현을 대체할 수 있다.
- 그러나 `MemberService` 클라이언트가 구현 클래스를 직접 선택하므로 구현 객체를 변경하려면 클라이언트 코드를 변경해야한다.

**어떻게 OCP를 지킬 수 있을까?**

- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
- Spring은 이런 역할을 해주는 프레임워크이다.

## 4 Liskov Substitution Principle

- 서브타입은 그것의 기반 타입으로 치환 가능해야 한다.
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
	- 부모가 할 수 있었던 일은 자식도 다 할 수 있어야 한다는 것을 의미한다.
- 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기
- 예시
	- 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리 더라도 앞으로 가야함

## 5 Interface Segregation Principle

- 큰 인터페이스 몇 개 보다 작은 인터페이스가 많은 것이 좋다.
- 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야 한다
- 클라이언트가 사용하지 않는 메서드를 강제로 구현하는 일이 없을 때까지 인터페이스를 분할해야한다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.
- 예시
	- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
	- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
	- 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음

## 6 Dependency Inversion Principle

- 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙 을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
	- 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다!
	- 구현체에 의존하게 되면 변경이 아주 어려워진다.

**DIP를 지키지 못하는 예**

```java
public class MemberService {
  private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

- `MemberRepository` 인터페이스를 구현한 `MemoryMemberRepository` 와 `JdbcMemberRepository`
- `MemberService` 클라이언트가 `MemberRepository` 인터페이스를 의존해 DIP를 지키고 있는 것처럼 보인다
- 그러나 `MemberService` 클라이언트가 구현 클래스를 직접 선택하므로 `MemoryMemberRepository`도 동시에 의존하고 있다.
- 즉 구현 클래스에 의존하고 있으므로 DIP를 위반하고있다.

### 6.1 DIP와 DI(Dependency Injection)의 관계

- DIP는 원칙(principle)이고, DI는 이 원칙을 지키기 위한 구체적인 기법(technique)입니다.
- 의존성 역전 원칙(DIP)이 "무엇을" 달성해야 하는지 말해준다면, 의존성 주입(DI)은 "어떻게" 달성할 수 있는지 알려줍니다.
- DIP 원칙을 따르려면 추상화에 의존해야 하는데, 실제로 코드가 동작하려면 결국 구체적인 구현체가 필요합니다.
- 이때 의존성 주입(DI)이 등장합니다. DI는 필요한 구현체를 외부에서 주입받아 사용함으로써:
  - 클래스가 직접 구현체를 생성하지 않고
  - 인터페이스를 통해 소통하게 하며
	- 구현체의 교체가 용이하도록 만들어줍니다.

## 참고

- 김영한 스프링 핵심 원리 - 기본편 강의
- 오브젝트 - 조영호