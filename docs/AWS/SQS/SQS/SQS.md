## 1 SQS

- AWS에서 제공하는 Simple Queue Service(SQS)는 완전 관리형 메시지 대기열 서비스로, 대규모 분산 애플리케이션에서 컴포넌트 간의 메시지를 안정적으로 전송하고 받을 수 있게 합니다. 
- SQS는 거의 무제한의 메시지 처리량과 규모 조정 가능성을 제공하여, 애플리케이션의 다양한 요구 사항을 충족시킵니다.


## 2 장점

### 2.1 보안

- 암호화
    - 전송 중 암호화: HTTPS API를 사용하여 전송 중인 데이터를 암호화합니다.
    - 저장 중 암호화: KMS 키를 사용하여 저장된 데이터를 암호화합니다.****
    - 클라이언트 측 암호화: 클라이언트가 직접 암호화/복호화를 수행하려는 경우에 사용할 수 있습니다.
- 액세스 제어
    - IAM 정책: IAM 정책을 사용하여 SQS API에 대한 접근을 제어할 수 있습니다.
    - SQS 접근 정책: S3 버킷 정책과 유사한 SQS 접근 정책을 사용하여 대기열에 대한 접근을 제어할 수 있습니다.
        - 계정 간 접근: 다른 계정에서 SQS 대기열에 접근할 수 있도록 설정할 수 있습니다.
        - 다른 서비스 허용: SNS, S3 등 다른 서비스가 SQS 대기열에 메시지를 쓸 수 있도록 허용할 수 있습니다.



### 2.2 내구성

- 메시지의 안전을 위해 Amazon SQS는 메시지를 여러 서버에 저장합니다. 
- 표준 큐는 적어도 한 번의 메시지 전달을 지원하며, FIFO 큐는 정확히 한 번의 메시지 처리를 지원합니다.



### 2.3 가용성

- Amazon SQS는 중복 인프라를 사용하여 메시지에 대한 고도로 동시 접근 및 메시지 생산 및 소비의 고가용성을 제공합니다.



### 2.4 확장성

- Amazon SQS는 각 버퍼링된 요청을 독립적으로 처리하여 로드 증가나 스파이크를 처리하기 위해 확장할 수 있습니다.



### 2.5 신뢰성

- Amazon SQS는 메시지를 처리하는 동안 잠가 두어 다중 생산자가 메시지를 보내고 다중 Consumer가 메시지를 동시에 받을 수 있도록 합니다.


### 2.6 사용자 정의

- 큐는 꼭 같을 필요가 없습니다. 
- 예를 들어, 큐에 기본 지연을 설정할 수 있습니다. 
- 256KB 이상의 메시지 콘텐츠를 Amazon Simple Storage Service(Amazon S3) 또는 Amazon DynamoDB를 사용하여 저장하고, Amazon SQS는 Amazon S3 객체에 대한 포인터를 보관할 수 있습니다. 또는 큰 메시지를 더 작은 메시지로 분할할 수 있습니다.



### 2.7 디커플링

- SQS는 애플리케이션 컴포넌트를 분리하여 서로 독립적으로 확장 가능하고, 유지 보수가 용이하게 합니다.
- 이를 통해 한 컴포넌트의 오류가 다른 컴포넌트에 영향을 주지 않도록 합니다.



## 3 유형

- SQS는 두 가지 주요 큐 유형을 제공합니다
	- Standard Queues
	- FIFO Queues
- Standard Queues는 애플리케이션이 한 번 이상 도착하고 순서대로 처리되지 않는 메시지를 처리할 수 있는 경우 사용할 수 있습니다.
- FIFO Queues는 작업 및 이벤트의 순서가 중요하거나 중복을 허용할 수 없는 애플리케이션 간의 메시징 전송을 위해 사용할 수 있습니다.



### 3.1 Standard Queues

- **무제한 처리량**: 표준 큐는 API 호출당 거의 무제한의 트랜잭션을 지원합니다.
- **적어도 한 번의 전달 보장**: 각 메시지는 최소 한 번 전달됩니다. 그러나 네트워크 지연이나 다른 요인으로 인해 가끔 메시지가 중복으로 전달될 수 있습니다.
- **Best-Effort Ordering**: 메시지는 대부분 전송된 순서대로 전달되지만, 완벽한 순서는 보장되지 않습니다.



### 3.2 FIFO Queues

- **높은 처리량**
	- FIFO 큐는 초당 최대 3,000개의 메시지 처리를 지원합니다(배치 사용 시). 
	- 배치를 사용하지 않을 경우 초당 최대 300개의 메시지(초당 300번의 전송, 수신 또는 삭제 작업)를 지원합니다.
- **단 한 번의 처리 보장**: 각 메시지는 정확히 한 번만 전달됩니다, 중복 없이.
- **엄격한 선입선출 순서**: 메시지는 엄격한 순서대로 전달되어, 전송된 순서를 정확하게 유지합니다.



## 4 SNS와 SQS의 차이점

- AWS에서 제공하는 Amazon SQS, Amazon SNS, 및 Amazon MQ는 모두 고도로 확장 가능하며 사용하기 쉬운 관리형 메시징 서비스입니다.
- 하지만 이들 서비스는 각각의 특정 시나리오와 요구 사항에 맞춰 설계되었습니다.



**SQS**

- Amazon Simple Queue Service(SQS)는 완전 관리형 메시지 대기열 서비스로, 대규모 분산 애플리케이션의 컴포넌트 간에 메시지를 안정적으로 전송하고 받습니다.
- SQS는 개발자가 메시지 처리량을 거의 무제한으로 확장할 수 있게 해주며, 애플리케이션의 다양한 요구 사항을 충족시킵니다.
- 메시지는 일반적으로 단일 구독자에 의해 처리되며, SQS와 SNS는 종종 함께 사용되어 팬아웃 메시징 어플리케이션을 만듭니다.



**SNS**

- Amazon Simple Notification Service(SNS)는 게시-구독 모델을 기반으로 하는 서비스로, 발행자(생산자)로부터 여러 구독자 엔드포인트(Consumer)에게 메시지 전달을 제공합니다.
- SNS는 메시지를 주제(topic)에 게시하며, 구독자는 이 주제를 구독하고 다양한 엔드포인트(예: Amazon SQS, Lambda, HTTP, 이메일, 모바일 푸시 알림)를 통해 메시지를 받습니다.
- SNS는 실시간 메시지 라우팅을 제공하며, 구독자가 메시지 발행 시간에 사용할 수 없는 경우 메시지를 나중에 검색할 수 없습니다.



**요약**

| SNS (Simple Notification Service) | SQS (Simple Queue Service) |
| --------------------------------- | -------------------------- |
| 퍼블리시/구독 모델 (Pub/Sub)              | 큐 기반 메시징 서비스               |
| 푸시 메커니즘                           | 폴 메커니즘                     |
| 메시지를 토픽에 게시하면 여러 구독자에게 전달됨        | 일반적으로 메시지는 단일 컨슈머에 의해 처리됨  |



## 5 메시지 

- 메시지는 SDK를 사용하여 SQS로 전송됩니다. 
- 이 과정에서 `SendMessage API`를 호출하여 메시지를 전송합니다.
- 메시지의 최대 용량은 256KB입니다. 
	- 각 메시지는 이 크기 제한 내에서 전송될 수 있으며, 256KB를 초과하는 메시지는 더 작은 메시지로 분할하거나 Amazon S3와 같은 다른 스토리지 서비스에 저장된 후 SQS 메시지에 해당 객체에 대한 포인터를 포함시킬 수 있습니다.
- 생성된 메시지는 Consumer가 삭제할 때까지 SQS에 보존됩니다.
	- 메시지는 기본적으로 4일 동안 보유되며, 최대 14일까지 설정할 수 있습니다.



### 5.1 수명 주기

- Amazon SQS 메시지의 수명 주기는 생성부터 삭제까지 다음과 같은 단계를 거칩니다.

1. **메시지 생성 및 전송**
    - 생산자가 메시지 A를 대기열로 보냅니다. 
    - 이 메시지는 Amazon SQS 서버에 중복으로 분산되어 저장됩니다.
2. **메시지 수신 및 처리**
    - Consumer가 메시지를 처리할 준비가 되면 대기열에서 메시지를 수신합니다. 
    - 이때 메시지 A가 반환됩니다. 
    - 메시지 A가 처리되는 동안에는 대기열에 남아 있지만, **가시성 타임아웃(visibility timeout)** 기간 동안 후속 수신 요청에는 반환되지 않습니다.
3. **메시지 삭제**
    - Consumer가 메시지 A를 처리 완료 후 대기열에서 삭제합니다.
    - 이렇게 하면 가시성 타임아웃이 만료된 후에 메시지가 다시 수신 및 처리되지 않도록 합니다.
4. **자동 삭제**
    - Amazon SQS는 최대 메시지 보존 기간을 초과한 메시지를 자동으로 삭제합니다.
    - 기본 메시지 보존 기간은 4일이며, SetQueueAttributes 작업을 사용하여 60초에서 1,209,600초(14일)까지 설정할 수 있습니다.



### 5.2 가시성 타임아웃(Visibility Timeout)

- 메시지가 큐에서 Consumer(consumer)에게 수신되고 처리될 때, 그 메시지는 큐에 남아 있습니다.
    - Amazon SQS는 자동으로 메시지를 삭제하지 않습니다.
- Amazon SQS는 분산 시스템이기 때문에 Consumer가 실제로 메시지를 받았는지 보장할 수 없습니다.
    - 따라서 Consumer는 메시지를 수신하고 처리한 후 큐에서 메시지를 삭제해야 합니다.
- 다른 Consumer들이 메시지를 다시 처리하지 못하도록 Amazon SQS는 가시성 타임아웃을 설정합니다.
    - 가시성 타임아웃은 다른 모든 Consumer들이 메시지를 수신하고 처리하지 못하게 하는 기간입니다.
    - 메시지의 기본 가시성 타임아웃은 30초입니다. 최소 값은 0초이며, 최대 값은 12시간입니다.
- 가시성 타임아웃은 Consumer가 대기열에서 메시지를 수신한 후 일정 기간 동안 다른 Consumer가 동일한 메시지를 수신하지 못하도록 하는 시간입니다.
    - 이 기간 동안 메시지는 "보이지 않는 상태"로 유지되며, Consumer가 해당 메시지를 처리할 수 있는 시간을 제공합니다.
- 가시성 타임아웃이 설정되면, 메시지를 수신한 Consumer는 타임아웃이 끝나기 전에 메시지를 처리하고 삭제해야 합니다.
    - 만약 타임아웃이 만료될 때까지 메시지가 삭제되지 않으면, 해당 메시지는 다시 대기열에서 보이게 되어 다른 Consumer가 수신할 수 있게 됩니다.
- 기본 가시성 타임아웃은 30초이며, 애플리케이션 요구 사항에 맞게 조정할 수 있습니다.
    - 소비자는 ChangeMessageVisibility API를 호출하여 더 많은 시간을 확보할 수 있습니다.



**ChangeMessageVisibility API**

- ChangeMessageVisibility API는 Consumer가 메시지의 가시성 타임아웃을 변경할 수 있게 해줍니다.
- 이 API를 사용하여 현재 가시성 타임아웃을 연장하거나 단축할 수 있습니다.
- 예를 들어, Consumer가 메시지를 처리하는 데 예상보다 더 많은 시간이 필요한 경우, 이 API를 호출하여 가시성 타임아웃을 연장할 수 있습니다.
- 반대로, 만약 메시지를 빨리 처리할 수 있을 것으로 예상되면, 타임아웃을 단축할 수도 있습니다.
- ChangeMessageVisibility API를 사용함으로써, 메시지가 다른 Consumer에게 재배포되는 것을 방지하면서 유연하게 메시지 처리 시간을 조정할 수 있습니다.



**가시성 타임아웃 조정**

- 가시성 타임아웃이 너무 길면(몇 시간), 소비자가 충돌할 경우 다시 처리하는 데 시간이 걸립니다.
- 가시성 타임아웃이 너무 짧으면(몇 초), 중복이 발생할 수 있습니다.



## 6 Consumer

### 6.1 Consumer의 역할

- **메시지 수신 및 처리**: Consumer는 SQS 대기열에서 메시지를 수신하고 이를 처리합니다.
- **메시지 삭제**: 처리된 메시지는 Consumer가 직접 삭제해야 합니다. 이는 Amazon SQS가 메시지를 자동으로 삭제하지 않기 때문입니다.
- **가시성 타임아웃 관리**: 메시지를 수신한 후, Consumer는 설정된 가시성 타임아웃 내에 메시지를 처리하고 삭제해야 합니다.



### 6.2 Consumer의 종류

- **단일 Consumer**
    - 하나의 애플리케이션 또는 서비스가 SQS 대기열에서 메시지를 수신하고 처리합니다.
    - 작은 규모의 애플리케이션이나 특정 작업을 위한 경우에 적합합니다.
- **다중 Consumer**
    - 여러 애플리케이션 또는 서비스가 동일한 SQS 대기열에서 메시지를 수신하고 처리합니다.
    - 확장성이 높으며, 다양한 애플리케이션이 동시에 메시지를 처리할 수 있습니다.
    - 이 경우 가시성 타임아웃을 통해 메시지가 여러 Consumer에 의해 중복 처리되지 않도록 관리합니다.
- **서버리스 Consumer**
    - AWS Lambda와 같은 서버리스 컴퓨팅 서비스를 사용하여 SQS 메시지를 처리합니다.
    - 메시지가 대기열에 도착하면 Lambda 함수가 자동으로 트리거되어 메시지를 처리합니다.
    - 확장성이 높고, 서버를 관리할 필요가 없으며, 이벤트 기반 처리에 적합합니다.
- **컨테이너 기반 Consumer**
    - Amazon ECS, EKS와 같은 컨테이너 오케스트레이션 서비스를 사용하여 SQS 메시지를 처리합니다.
    - 컨테이너 기반 애플리케이션이 자동으로 스케일링되어 메시지를 처리합니다.
    - 마이크로서비스 아키텍처와 잘 맞으며, 복잡한 워크로드에 적합합니다.



### 6.3 Consumer 동작 과정

1. **메시지 수신**
    - Consumer는 `ReceiveMessage` API를 호출하여 SQS 대기열에서 메시지를 수신합니다.
    - 메시지가 수신되면 해당 메시지는 가시성 타임아웃 동안 다른 Consumer에게 보이지 않게 됩니다.
2. **메시지 처리**
    - Consumer는 수신한 메시지를 처리합니다. 처리 과정은 애플리케이션의 로직에 따라 다를 수 있습니다.
    - 예를 들어, 주문 처리를 위한 메시지라면 주문 데이터를 데이터베이스에 저장하거나 다른 서비스에 전송할 수 있습니다.
3. **메시지 삭제**
    - 메시지가 성공적으로 처리되면, Consumer는 `DeleteMessage` API를 호출하여 메시지를 삭제합니다.
    - 삭제되지 않은 메시지는 가시성 타임아웃이 만료되면 다시 대기열에 나타나 다른 Consumer가 처리할 수 있게 됩니다.



### 6.4 Consumer 관리 팁

- **적절한 가시성 타임아웃 설정**:
    - 메시지를 처리하는 데 필요한 시간에 맞게 가시성 타임아웃을 설정해야 합니다.
    - 타임아웃이 너무 짧으면 메시지가 중복 처리될 수 있으며, 너무 길면 대기 시간이 증가할 수 있습니다.
- **오토 스케일링 사용**:
    - 다중 Consumer 또는 서버리스 Consumer의 경우, 오토 스케일링을 통해 처리 용량을 동적으로 조정할 수 있습니다.
    - 이는 트래픽 스파이크를 효과적으로 처리하는 데 도움이 됩니다.
- **에러 처리**:
    - 메시지 처리 중 오류가 발생할 경우, 처리 실패한 메시지를 DLQ(Dead Letter Queue)로 전송하여 나중에 분석하고 재처리할 수 있습니다.



### 6.5 Short and Long Polling

- SQS는 메시지를 효율적으로 검색하기 위해 short polling과 long polling 두 가지 방법을 제공합니다.



**Short Polling**

- 기본 설정으로, 큐가 비어 있는 경우 즉시 응답을 반환합니다.
- 메시지가 없는 경우에도 API 호출이 계속 발생하여 불필요한 요청이 많아질 수 있습니다.



**Long Polling**

- 더 효율적인 메시지 처리를 위해, 큐가 비어 있더라도 서버는 메시지가 도착할 때까지 응답을 지연시킵니다.
    - 이는 불필요한 API 호출 수를 줄이고, 메시지가 도착하는 즉시 처리할 수 있도록 합니다.
- Long polling은 비용을 절감하고 메시지 처리의 효율성을 높이는 방법으로 권장됩니다.
    - 큐를 비우는 동안의 대기 시간을 줄여 서버 리소스를 효율적으로 사용합니다.
    - 메시지가 도착하자마자 즉시 처리할 수 있으므로 처리 지연이 감소합니다.
- Long polling을 사용하면 애플리케이션의 효율성을 높이고 지연 시간을 줄일 수 있습니다.
    - 대기 시간은 1초에서 20초 사이로 설정할 수 있으며, 20초가 권장됩니다.
- Long polling은 Short polling보다 선호됩니다.
- Long polling은 큐 수준에서 또는 API 수준에서 `WaitTimeSeconds` 파라미터를 사용하여 활성화할 수 있습니다.



**Short Polling과 Long Polling의 비교**

- Short polling은 즉각적인 응답을 제공하므로 간단한 시스템에 적합할 수 있지만, 메시지 대기 시간이 길어질 수 있습니다.
- Long polling은 시스템 리소스를 더 효율적으로 사용하며, 메시지 도착 즉시 처리가 가능해 더 나은 성능을 제공합니다.
- 비용 측면에서 보면, long polling은 불필요한 API 호출을 줄여 비용 절감에 기여합니다.



**사용 사례**

- Short polling은 작은 규모의 어플리케이션이나, 메시지가 자주 도착하지 않는 경우 유용할 수 있습니다.
- Long polling은 트래픽이 많은 대규모 시스템이나, 실시간 메시지 처리가 중요한 경우 적합합니다.



## 7 SQS와 Auto Scaling Group(ASG) 통합

- Amazon SQS와 Auto Scaling Group(ASG)의 통합은 메시지 처리의 자동화 및 효율성을 극대화하는 데 유용합니다.



**구성 요소**

- **SQS Queue**: 메시지를 저장하고 Consumer에게 전달하는 큐입니다.
- **EC2 Instances**: 메시지를 처리하는 작업자 노드입니다.
- **Auto Scaling Group (ASG)**: EC2 인스턴스를 자동으로 스케일링하여 메시지 처리 능력을 조절합니다.
- **CloudWatch Metric – Queue Length**: SQS 큐의 길이를 모니터링하여 큐에 있는 메시지 수를 측정합니다.
- **CloudWatch Alarm**: 큐 길이가 임계값을 초과할 때 경고를 생성합니다.



**동작 원리**

- **메시지 폴링**: EC2 인스턴스는 SQS 큐에서 메시지를 폴링하여 수신하고 처리합니다.
- **큐 길이 모니터링**: CloudWatch는 SQS 큐의 길이를 모니터링합니다.
    - CloudWatch Metric인 `ApproximateNumberOfMessages`를 사용하여 큐에 있는 메시지 수를 측정합니다.
- **알람 설정**: CloudWatch Alarm은 큐 길이가 설정된 임계값을 초과할 때 경고를 생성합니다.
- **스케일링**: CloudWatch Alarm이 트리거되면, Auto Scaling Group이 EC2 인스턴스 수를 조절하여 메시지 처리 능력을 증가시킵니다.
    - ASG는 큐 길이가 줄어들면 자동으로 인스턴스 수를 감소시켜 비용을 절감합니다.



**장점**

- **자동 스케일링**: 메시지 수에 따라 EC2 인스턴스를 자동으로 증감시켜 효율적인 리소스 사용이 가능합니다.
- **비용 절감**: 필요할 때만 인스턴스를 추가로 사용하므로, 불필요한 리소스 사용을 줄여 비용을 절감할 수 있습니다.
- **높은 가용성**: 메시지 처리의 지연을 최소화하고, 대규모 트래픽 증가에 유연하게 대응할 수 있습니다.



**예시**

- 예를 들어, 쇼핑몰의 주문 처리를 위해 SQS와 ASG를 통합하면, 주문량이 급증할 때 자동으로 EC2 인스턴스 수를 늘려 처리 지연을 방지할 수 있습니다.
- 주문량이 줄어들면 자동으로 인스턴스 수를 줄여 비용을 절감할 수 있습니다.



## 8 데이터 순서

### 8.1 데이터 순서 보장

- SQS는 두 가지 큐 유형을 제공합니다: Standard Queues와 FIFO Queues.
- Standard Queues는 메시지 순서를 보장하지 않으며, 메시지가 최소 한 번 전달되는 것을 보장합니다.
- FIFO Queues는 메시지 순서를 엄격히 보장하며, 각 메시지가 정확히 한 번 전달되는 것을 보장합니다.



### 8.2 메시지 그룹화 및 Group ID

- SQS FIFO 큐에서 메시지 순서를 유지하려면 Group ID를 사용합니다.
- Group ID는 관련 메시지들을 그룹화하여, 동일한 Group ID를 가진 메시지들이 순서대로 처리되도록 합니다.
- 예를 들어, 트럭의 GPS 데이터를 SQS FIFO 큐로 전송할 때, 각 트럭의 "truck_id"를 Group ID로 사용하여 트럭별로 데이터를 순서대로 처리할 수 있습니다.
- 메시지를 Group ID를 사용하여 전송하면, 해당 Group ID에 속한 메시지들은 순서대로 소비됩니다.



### 8.3 예시: 트럭의 GPS 데이터

- 100대의 트럭(truck_1, truck_2, ... truck_100)이 정기적으로 GPS 위치 데이터를 SQS FIFO 큐로 전송한다고 가정합니다.
- 각 트럭의 이동을 정확하게 추적하려면 데이터를 순서대로 소비해야 합니다.
- 이를 위해 데이터를 "truck_id"라는 Group ID 값으로 SQS FIFO 큐에 전송합니다.
- 동일한 Group ID를 가진 메시지는 항상 순서대로 처리됩니다.
- 예를 들어, 트럭 truck_1의 모든 메시지는 truck_1 Group ID로 전송되어 순서대로 처리됩니다.
- 이 방식으로 최대 100개의 Group ID를 사용할 수 있으며, 최대 100개의 소비자가 병렬로 메시지를 처리할 수 있습니다.
- SQS FIFO 큐는 초당 최대 300개의 메시지(또는 배치를 사용할 경우 초당 최대 3000개의 메시지)를 처리할 수 있습니다.