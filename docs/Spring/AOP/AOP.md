## 1. Aspect Oriented Programming

- 관점 지향 프로그래밍(AOP)은 객체 지향 프로그래밍(OOP)을 보완하는 프로그램 구조에 대한 또 다른 사고 방식을 제공합니다.
- OOP에서의 핵심 모듈화 단위는 클래스인 반면, AOP에서는 관점(Aspect)이 모듈화 단위입니다.
- 관점은 여러 타입과 객체에 걸쳐 있는 관심사(예: 트랜잭션 관리)의 모듈화를 가능하게 합니다.
- 이러한 관심사는 AOP 문헌에서 종종 "횡단 관심사(crosscutting concerns)"라고 불립니다.
- Spring의 핵심 구성 요소 중 하나는 AOP 프레임워크입니다.
- Spring IoC 컨테이너는 AOP에 의존하지 않지만(즉, 원하지 않으면 AOP를 사용할 필요가 없음), AOP는 Spring IoC를 보완하여 매우 강력한 미들웨어 솔루션을 제공합니다.

## 2. AOP Concepts

- AOP 개념과 용어를 정의하는 것으로 시작하겠습니다. 이 용어들은 Spring에만 국한된 것이 아닙니다.
- 불행하게도, AOP 용어는 특별히 직관적이지 않습니다. 그러나 Spring이 자체 용어를 사용한다면 더욱 혼란스러울 것입니다.

### 2.1 Aspect

- 여러 클래스에 걸쳐 있는 관심사의 모듈화입니다.
- 트랜잭션 관리는 엔터프라이즈 Java 애플리케이션에서 횡단 관심사의 좋은 예입니다.
- Spring AOP에서 관점은 일반 클래스(스키마 기반 접근 방식) 또는 @Aspect 어노테이션이 달린 일반 클래스(@AspectJ 스타일)를 사용하여 구현됩니다.

### 2.2 Joinpoint

- 메서드 실행이나 예외 처리와 같은 프로그램 실행 중의 특정 지점입니다.
- Spring AOP에서 조인 포인트는 항상 메서드 실행을 나타냅니다.

### 2.3 Advice

- 특정 조인 포인트에서 관점이 취하는 행동입니다.
- 어드바이스의 다양한 유형에는 "around", "before", "after" 어드바이스가 있습니다.
- Spring을 포함한 많은 AOP 프레임워크는 어드바이스를 인터셉터로 모델링하고 조인 포인트 주변에 인터셉터 체인을 유지합니다.

### 2.4 Pointcut

- 조인 포인트와 일치하는 조건식입니다.
- 어드바이스는 포인트컷 표현식과 연결되어 해당 포인트컷과 일치하는 모든 조인 포인트에서 실행됩니다(예: 특정 이름을 가진 메서드의 실행).
- 포인트컷 표현식과 일치하는 조인 포인트의 개념은 AOP의 핵심이며, Spring은 기본적으로 AspectJ 포인트컷 표현식 언어를 사용합니다.

### 2.5 Introduction

- 타입을 대신하여 추가 메서드나 필드를 선언하는 것입니다.
- Spring AOP를 사용하면 어떤 어드바이스된 객체에도 새로운 인터페이스(및 해당 구현)를 도입할 수 있습니다.
- 예를 들어, 캐싱을 단순화하기 위해 인트로덕션을 사용하여 빈이 IsModified 인터페이스를 구현하도록 할 수 있습니다. (인트로덕션은 AspectJ 커뮤니티에서 inter-type 선언으로 알려져 있습니다.)

### 2.6 Target object

- 하나 이상의 관점에 의해 어드바이스되는 객체입니다.
- "어드바이스된 객체"라고도 합니다. Spring AOP는 런타임 프록시를 사용하여 구현되므로 이 객체는 항상 프록시된 객체입니다.

### 2.7 AOP proxy

- 관점 계약(어드바이스 메서드 실행 등)을 구현하기 위해 AOP 프레임워크에 의해 생성된 객체입니다.
- Spring 프레임워크에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시입니다.

### 2.8 Weaving

- 관점을 다른 애플리케이션 타입이나 객체와 연결하여 어드바이스된 객체를 만드는 과정입니다.
- 이는 컴파일 시간(예: AspectJ 컴파일러 사용), 로드 시간 또는 런타임에 수행될 수 있습니다.
- Spring AOP는 다른 순수 Java AOP 프레임워크와 마찬가지로 런타임에 위빙을 수행합니다.

## 3 AOP Advice Types

- Spring AOP는 다음과 같은 유형의 어드바이스를 포함합니다:
- Before 어드바이스: 조인 포인트 전에 실행되지만 조인 포인트로의 실행 흐름을 방지할 수 없는 어드바이스입니다(예외를 던지지 않는 한).
- After returning 어드바이스: 조인 포인트가 정상적으로 완료된 후 실행될 어드바이스입니다(예: 메서드가 예외를 던지지 않고 반환하는 경우).
- After throwing 어드바이스: 메서드가 예외를 던져 종료되는 경우 실행될 어드바이스입니다.
- After (finally) 어드바이스: 조인 포인트가 종료되는 방식(정상 또는 예외적 반환)에 관계없이 실행될 어드바이스입니다.
- Around 어드바이스: 메서드 호출과 같은 조인 포인트를 둘러싸는 어드바이스입니다. 이는 가장 강력한 종류의 어드바이스입니다. Around 어드바이스는 메서드 호출 전후에 사용자 정의 동작을 수행할 수 있습니다. 또한 조인 포인트로 진행할지 또는 자체 반환 값을 반환하거나 예외를 던져 어드바이스된 메서드 실행을 우회할지 선택할 책임이 있습니다.

### 3.1 Before Advice

### 3.2 After Returning Advice

### 3.3 After Throwing Advice

### 3.4 After (Finally) Advice

### 3.5 Around Advice

- 메서드 호출과 같은 조인 포인트를 둘러싸는 어드바이스입니다. 이는 가장 강력한 종류의 어드바이스입니다. 
- Around 어드바이스는 메서드 호출 전후에 사용자 정의 동작을 수행할 수 있습니다. 
- 또한 조인 포인트로 진행할지 또는 자체 반환 값을 반환하거나 예외를 던져 어드바이스된 메서드 실행을 우회할지 선택할 책임이 있습니다.

### 3.6 타입 선택 가이드

- Around 어드바이스는 가장 일반적인 유형의 어드바이스입니다. 
- Spring AOP는 AspectJ와 같이 다양한 어드바이스 유형을 제공하므로, 필요한 동작을 구현할 수 있는 가장 간단한 어드바이스 유형을 사용하는 것이 좋습니다. 
- 예를 들어, 메서드의 반환 값으로 캐시만 업데이트하면 되는 경우, Around 어드바이스가 동일한 작업을 수행할 수 있지만 After returning 어드바이스를 구현하는 것이 더 좋습니다. 
- 가장 특정한 어드바이스 유형을 사용하면 오류 가능성이 적은 더 간단한 프로그래밍 모델을 제공합니다. 
- 예를 들어, Around 어드바이스에 사용되는 JoinPoint의 proceed() 메서드를 호출할 필요가 없으므로 이를 호출하지 못하는 실수를 할 수 없습니다.

## 4. AspectJ와의 관계

- Spring AOP는 100% 완벽한 AOP 솔루션을 제공하는 것이 아니라, Spring의 다른 기능들과 잘 통합되어 일반적인 기업용 Java 애플리케이션의 문제(트랜잭션 관리, 보안, 로깅 등)를 해결하는 데 초점을 맞추고 있습니다.
- 더 강력하고 세밀한 AOP가 필요하면 AspectJ를 사용할 수 있고, Spring은 이와의 통합도 지원합니다.

### 4.1 Spring AOP의 현재 지원 범위

- Spring AOP는 현재 메서드 실행 조인 포인트(Spring 빈의 메서드 실행에 대한 어드바이스)만 지원합니다.
- 필드 접근 및 업데이트 조인 포인트에 대한 어드바이스가 필요하다면 AspectJ와 같은 언어를 고려해보세요.

### 4.2 Spring AOP의 접근 방식

- Spring AOP의 접근 방식은 대부분의 다른 AOP 프레임워크와 다릅니다. 
- 목표는 가장 완벽한 AOP 구현을 제공하는 것이 아닙니다
- 오히려 목표는 AOP 구현과 Spring IoC 간의 긴밀한 통합을 제공하여 엔터프라이즈 애플리케이션의 일반적인 문제를 해결하는 데 도움을 주는 것입니다.
- Spring 프레임워크의 AOP 기능은 일반적으로 Spring IoC 컨테이너와 함께 사용됩니다.
- 이는 다른 AOP 구현과의 중요한 차이점입니다.
- 매우 세분화된 객체(일반적으로 도메인 객체)에 대한 어드바이스와 같은 일부 작업은 AspectJ가 최선의 선택입니다.
- 그러나 경험에 따르면 Spring AOP는 AOP에 적합한 엔터프라이즈 Java 애플리케이션의 대부분의 문제에 탁월한 솔루션을 제공합니다.

### 4.3 AspectJ와의 관계

- Spring AOP는 포괄적인 AOP 솔루션을 제공하기 위해 AspectJ와 경쟁하려고 하지 않습니다. 
- Spring AOP와 같은 프록시 기반 프레임워크와 AspectJ와 같은 완전한 프레임워크 모두 가치가 있으며, 경쟁이 아닌 상호 보완적입니다.
- Spring은 일관된 Spring 기반 애플리케이션 아키텍처 내에서 AOP의 모든 사용을 가능하게 하기 위해 Spring AOP와 IoC를 AspectJ와 원활하게 통합합니다. 

## 5. AOP 프록시

- Spring AOP는 AOP 프록시로 표준 JDK 동적 프록시를 기본적으로 사용합니다. 
  - 이는 모든 인터페이스(또는 인터페이스 집합)가 프록시될 수 있게 합니다.
- Spring AOP는 CGLIB 프록시도 사용할 수 있습니다. 
  - 이는 인터페이스가 아닌 클래스를 프록시하는 데 필요합니다. 
  - 기본적으로 비즈니스 객체가 인터페이스를 구현하지 않으면 CGLIB가 사용됩니다. 
- 클래스보다는 인터페이스를 기반으로 프로그래밍하는 것이 좋은 관행이므로, 비즈니스 클래스는 일반적으로 하나 이상의 비즈니스 인터페이스를 구현합니다. 
- 인터페이스에 선언되지 않은 메서드에 어드바이스가 필요하거나 구체적인 타입으로 프록시된 객체를 메서드에 전달해야 하는 경우에는 CGLIB 사용을 강제할 수 있습니다.

### 5.1 Spring AOP의 동작 방식

- Spring AOP는 '프록시 기반'입니다. 
- 즉, 원본 객체 대신 프록시 객체가 사용되어 메서드 호출을 가로채고 추가 동작(어드바이스)을 수행합니다.
- 이 방식은 AspectJ와 같은 바이트코드 변환 방식과는 다르게 작동합니다.
- Spring AOP의 프록시 기반 특성은 일부 제한사항을 가지고 있으며, 이를 이해하는 것이 Spring AOP를 효과적으로 사용하는 데 중요합니다. 
- 예를 들어, 같은 클래스 내의 메서드 호출은 프록시를 거치지 않기 때문에 AOP가 적용되지 않는 등의 특성이 있습니다.

## 6. Aspect 선언하기

- @AspectJ 애스펙트(즉, @Aspect 애노테이션이 있는) 클래스로 정의된 애플리케이션 컨텍스트의 모든 빈은 Spring에 의해 자동으로 감지되고 Spring AOP를 구성하는 데 사용됩니다.
  - 이를 위해 @AspectJ 지원을 활성화 해야 합니다. Spring Boot의 경우 'spring-boot-starter-aop' 의존성을 추가하면 자동으로 활성화됩니다.
- 애스펙트 클래스는 @Configuration 클래스의 @Bean 메서드를 통해 등록하거나, 다른 Spring 관리 빈과 마찬가지로 클래스패스 스캐닝을 통해 Spring이 자동 감지하도록 할 수 있습니다.
- 그러나 @Aspect 애노테이션만으로는 클래스패스에서 자동 감지하기에 충분하지 않다는 점에 유의하세요. 
  - 이를 위해 별도의 @Component 애노테이션을 추가해야 합니다.

```java
@Aspect
@Component
public class NotVeryUsefulAspect {
}
```

- 다른 클래스와 마찬가지로 메서드와 필드를 가질 수 있습니다. 
- 또한 포인트컷, 어드바이스 및 인트로덕션(inter-type) 선언을 포함할 수 있습니다.

## 7. Pointcut 선언하기

- 포인트컷은 관심 조인 포인트를 결정하여 어드바이스가 실행되는 시점을 제어합니다. 
- Spring AOP는 Spring 빈에 대한 메서드 실행 조인 포인트만 지원하므로, 포인트컷을 Spring 빈의 메서드 실행과 매칭하는 것으로 생각할 수 있습니다.
- 포인트컷 선언은 두 부분으로 구성됩니다
  - 이름과 매개변수로 구성된 시그니처
  - 관심 있는 메서드 실행을 정확히 결정하는 포인트컷 표현식

```java
@Pointcut("execution(* transfer(..))") // 포인트컷 표현식
private void anyOldTransfer() {} // 포인트컷 시그니처
```

- @AspectJ 스타일의 AOP에서 포인트컷 시그니처는 일반 메서드 정의로 제공되며, 포인트컷 표현식은 @Pointcut 애노테이션을 사용하여 표시됩니다.
- 포인트컷 시그니처 역할을 하는 메서드는 반환 타입이 void여야 합니다.
- 이 예시는 'transfer'라는 이름의 모든 메서드 실행과 일치하는 'anyOldTransfer'라는 포인트컷을 정의합니다.

### 7.1 지원되는 포인트컷 지정자(PCD)



## 참고

- https://docs.spring.io/spring-framework/reference/core/aop.html
- https://docs.spring.io/spring-framework/reference/core/aop/introduction-defn.html
- https://docs.spring.io/spring-framework/reference/core/aop/introduction-spring-defn.html
- https://docs.spring.io/spring-framework/reference/core/aop/introduction-proxies.html
- https://docs.spring.io/spring-framework/reference/core/aop/ataspectj/at-aspectj.
- https://docs.spring.io/spring-framework/reference/core/aop/ataspectj/pointcuts.html