---
title: "WebSocket 프레임"
description: "WebSocket 프로토콜의 핵심인 프레임의 구조를 자세히 살펴봅니다. 프레임의 구성 요소, 마스킹, 프래그멘테이션 등 WebSocket 프레임의 모든 측면을 실제 예제와 함께 상세히 설명합니다."
tags: ["WEBSOCKET_API", "RESTFUL_API", "FRONTEND", "BACKEND", "WEB"]
keywords: ["웹소켓", "WebSocket", "프레임", "Frame", "마스킹", "Masking", "프래그멘테이션", "Fragmentation", "프로토콜", "Protocol", "네트워크", "Network", "웹", "Web", "프레이밍", "Framing"]
draft: false
hide_title: true
---

## 1. WebSocket 프레임의 기본 구조

WebSocket 프레임은 TCP 기반의 스트림 지향 프로토콜에서 메시지 단위의 통신을 가능하게 하는 핵심 구조입니다. RFC 6455에 정의된 WebSocket 프레임의 구조는 다음과 같습니다:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

### 1.1 프레임 크기의 특징

- 최소 크기: 2바이트 (서버에서 페이로드 없는 close 메시지)
- 최대 헤더 크기: 14바이트 (클라이언트에서 64KB 이상의 페이로드를 가진 메시지)
- 클라이언트 → 서버 메시지 예시: "over9000" 전송 시 14바이트 (마스킹으로 인한 랜덤성 포함)
- 서버 → 클라이언트 메시지 예시: 동일한 "over9000" 전송 시 10바이트로 고정

## 2. Payload Length(페이로드 길이)

WebSocket은 TCP의 스트림 특성을 고려하여 메시지 프레이밍을 구현합니다.

### 2.1 길이 표현 방식

프레임의 두 번째 바이트의 하위 7비트는 다음과 같이 페이로드 길이를 나타냅니다:

- 0-125: 직접적인 페이로드 길이
- 126: 다음 2바이트가 페이로드 길이 (16비트)
- 127: 다음 8바이트가 페이로드 길이 (64비트)

### 2.2 길이 계산 예시

```javascript
// 5바이트 메시지 "hello"의 경우
byte2 & 127 == 5 // 직접 길이 표현

// 300바이트 메시지의 경우
byte2 & 127 == 126 // 다음 2바이트에서 길이 확인
// 다음 2바이트: 1, 44 (256 + 44 = 300)
```

:::info
이러한 가변 길이 방식은 작은 메시지(125바이트 이하)의 효율성을 높이지만, 구현의 복잡성을 증가시킵니다. 고정 4바이트 길이 방식이 더 단순할 수 있습니다.
:::

## 3. Masking(마스킹)

### 3.1 마스킹의 목적

마스킹은 클라이언트 측 악성 코드가 정확한 바이트 시퀀스를 제어하는 것을 방지하기 위한 보안 기능입니다.

### 3.2 마스킹 규칙

- 클라이언트 → 서버: 모든 메시지는 반드시 마스킹 필요
- 서버 → 클라이언트: 마스킹 사용 금지
- 마스킹 키: 4바이트 길이, 예측 불가능해야 함

### 3.3 마스킹 프로세스

```javascript
// "hello" 메시지의 마스킹 예시 (ASCII/UTF-8)
원본: 104, 101, 108, 108, 111
마스크: 1, 2, 3, 4
마스킹 결과: 105, 103, 111, 104, 110 

// 각 바이트별 XOR 연산
'h' ^ 1, 'e' ^ 2, 'l' ^ 3, 'l' ^ 4, 'o' ^ 1
```

:::warning
마스킹을 우회하는 것(예: 0,0,0,0 마스크 사용)은 보안상 위험할 수 있으며, 프로토콜 명세를 위반합니다.
:::

## 4. Message Type(메시지 타입)

WebSocket 프레임은 6가지 타입을 지원합니다:

- text: UTF-8 검증 필요
- binary: 바이너리 데이터
- ping: 연결 상태 확인
- pong: ping에 대한 응답
- close: 연결 종료
- continuation: 프래그먼트 연속

### 4.1 타입 특성

- text vs binary: UTF-8 유효성 검사가 필요한 text보다 binary 사용 권장
- ping/pong: 애플리케이션 레벨에서 구현하는 것이 더 효율적
- close: 페이로드의 처음 2바이트는 close code를 포함해야 함

## 5. Fragmentation(프래그멘테이션)

### 5.1 프래그멘테이션의 목적

1. 스트리밍: 전체 길이를 모르는 상태에서 데이터 전송
2. 대형 메시지 중단: 컨트롤 프레임 삽입 가능
3. 프록시 지원: 작은 버퍼로 메시지 분할 가능

### 5.2 프래그멘테이션 규칙

- text/binary 프레임만 분할 가능
- 프래그먼트 사이에는 컨트롤 프레임만 삽입 가능
- 한 번에 하나의 프래그먼트 메시지만 처리

:::danger
프래그멘테이션은 구현의 복잡성을 크게 증가시키며, 메모리 관리를 어렵게 만듭니다.
:::

## 6. 구현 시 고려사항

### 6.1 Autobahn 테스트 스위트

Autobahn 테스트 스위트는 WebSocket 구현의 정확성을 검증하는 중요한 도구입니다:

- 클라이언트/서버 구현 검증
- 포괄적인 테스트 케이스 제공
- 프로토콜 준수 여부 확인

### 6.2 최적화 고려사항

- binary 타입 사용으로 UTF-8 검증 오버헤드 제거
- 프래그멘테이션 사용 최소화
- 애플리케이션 레벨 ping/pong 구현 검토

## 7. 결론

WebSocket 프레임의 구조는 다음과 같은 특징들로 인해 복잡성을 가집니다:

- 가변 길이 페이로드
- 클라이언트 측 필수 마스킹
- 메시지 타입 구분
- 프래그멘테이션 지원

이러한 특징들은 구현의 복잡성을 증가시키지만, 각각의 설계 결정에는 그만한 이유가 있습니다. 효율적인 WebSocket 구현을 위해서는 이러한 특징들을 잘 이해하고 적절히 활용하는 것이 중요합니다.